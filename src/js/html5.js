import utils from './utils'class Html5 {  constructor(player,clear) {    this.option = player.option;    this.player = player;    this.type = player.option.video.type;    this.readOny = [      'controller',      'buffered',      'currentSrc',      'duration',      'ended',      'error',      'networkState',      'played',      'readyState',      'startDate'    ];    this.readWrite = [      'autoplay',      'currentTime',      'defaultMuted',      'loop',      'muted',      'paused',      'preload',      'src',      'volume'    ];    if (clear){      player.tel.createEl();      this.video=player.tel.video;    }else{      this.video=player.tel.video;    }    this.initproxy();  }  initproxy() {    const mapGetter = (type) => {      Object.defineProperty(this, type, {        get: function() {          return this.video[type];        }      });    };    const mapGetterSetter = (type) => {      Object.defineProperty(this, type, {        get: function() {          return this.video[type];        },        set: function(val) {          this.video[type] = val;        }      });    };    for (let i = 0; i < this.readOny.length; i++) {      mapGetter(this.readOny[i]);    }    for (let i = 0; i < this.readWrite.length; i++) {      mapGetterSetter(this.readWrite[i]);    }  }  play(){    return new Promise((res,rej)=>{      this.video.play().then(res).catch(rej)    })  }  pause(){    this.video.pause()  }  init() {    return new Promise((res, rej) => {      if (/.mp4$/.test(this.option.src)) {        this.type = 'mp4';      }      if (/.flv$/.test(this.option.src)) {        this.type = 'flv';      }      if (/.mpd$/.test(this.option.src)) {        this.type = 'dash';      }      if (/.m3u8$/.test(this.option.src)) {        this.type = 'hls';      }      if (/.ts$/.test(this.option.src)) {        this.type = 'hls';      }      switch (this.type) {        case 'flv':          this.flvjs().then(this.flvEvent.bind(this)).then(this.videoEvent.bind(this)).then(res).catch(rej);          break;        case 'hls':          this.hlsjs().then(this.hlsEvent.bind(this)).then(this.videoEvent.bind(this)).then(res).catch(rej);          break;        case 'webtorrent':         this.webtorrentjs().then(this.videoEvent.bind(this)).then(res).catch(rej);          break;          case 'dash':            break        case 'mp4':          this.videoEvent().then(res);          break;        default:          this.videoEvent().then(res);          break;      }    });  }  flvjs() {    return new Promise((res, rej) => {      if (flvjs && flvjs.isSupported()) {        flvjs.LoggingControl.enableAll = this.option.debug;        const flvPlayer = flvjs.createPlayer({          type: 'flv',          isLive: this.option.live,          url: this.option.video.src        });        res(flvPlayer);      } else {        rej();      }    });  }  hlsjs() {    return new Promise((res, rej) => {      if (Hls && Hls.isSupported()) {        const hls = new Hls({          debug: this.option.debug        });        res(hls);      } else {        rej();      }    });  }  dashjs(){    return new Promise((res,rej)=>{      if (dashjs) {        dashjs.MediaPlayer().create().initialize(this.video, this.option.src, false);      }else {        rej()      }    })  }  webtorrentjs(){    return new Promise((res, rej) => {      if (!WebTorrent){        rej()      }      if (!WebTorrent.WEBRTC_SUPPORT){        rej()      }       this.player.container.classList.add('player-loading');       const client = new WebTorrent();      const torrentId = this.option.src;      client.add(torrentId,  (torrent)=>{        // Torrents can contain many files. Let's use the .mp4 file        var file = torrent.files.find( (file)=> {          return file.name.endsWith('.mp4')        })        res()        file.renderTo(this.video, {          autoplay: this.option.autoplay        }, () => {          this.player.container.classList.remove('player-loading');        });        // file.deselect()        // Display the file by adding it to the DOM.        // Supports video, audio, image files, and more!      })    });  }  flvEvent(flv) {    flv.attachMediaElement(this.video);    flv.load();    flv.on('error', (...arg) => {      this.emit('error', ...arg);    });    this.flv = flv;    return Promise.resolve();  }  hlsEvent(hls) {    hls.loadSource(this.option.video.src);    hls.attachMedia(this.video);    this.hls = hls;    return Promise.resolve();  }  videoEvent() {    const event = this.player.event.playeEvent;    for (let i = 0; i < event.length; i++) {      this.video.addEventListener(event[i], e => {        this.emit(event[i], e);      });    };    this.player.volume(this.option.volume,false,true)    utils.sleep(500).then(()=>{      this.player.event.emit('ready')    })    return Promise.resolve();  }  emit(...arg) {    this.player.event.emit(...arg);  }  destroy() {    this.flv && this.flv.destroy();    this.hls && this.hls.destroy();    this.video.src='';    delete this.video;    this.flv&&delete this.flv;    this.hls&&delete this.hls;    this.player.event.off()  }}export default Html5;